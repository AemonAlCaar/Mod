
#include "CvGameCoreDLL.h"

#include "autogenerated/AutoXmlDeclare.h"

#ifndef HARDCODE_XML_VALUES
CivEffectTypes   CIV_EFFECT_DEFAULT_ALL      = NO_CIV_EFFECT;
CivEffectTypes   CIV_EFFECT_DEFAULT_EUROPEAN = NO_CIV_EFFECT;
CivEffectTypes   CIV_EFFECT_DEFAULT_NATIVE   = NO_CIV_EFFECT;
CivEffectTypes   CIV_EFFECT_DEFAULT_KING     = NO_CIV_EFFECT;
CivEffectTypes   CIV_EFFECT_DEFAULT_HUMAN    = NO_CIV_EFFECT;
CivEffectTypes   CIV_EFFECT_DEFAULT_AI       = NO_CIV_EFFECT;

HurryTypes       HURRY_GOLD                  = NO_HURRY;
HurryTypes       HURRY_IMMIGRANT             = NO_HURRY;
#endif


static void DisplayXMLmissingError(YieldTypes eYield, const char* szName)
{
	if (eYield == NO_YIELD)
	{
		char szMessage[1024];

		sprintf(szMessage, "No CvYieldInfo is assigned to %s", szName);
		gDLL->MessageBox(szMessage, "Missing XML entry Error");
	}
}

static void DisplayXMLmissingError(bool bSuccess, const char* szName)
{
	if (!bSuccess)
	{
		char szMessage[1024];

		sprintf(szMessage, "XML is missing the mandatory entry: %s", szName);
		gDLL->MessageBox(szMessage, "Missing XML entry Error");
	}
}

static void DisplayXMLhardcodingError(bool bSuccess, const char* szName, bool bAlwaysHardcoded)
{
	if (!bSuccess)
	{
		char szMessage[1024];

		sprintf(szMessage, "DLL hardcoding error: %s\n%s", szName,
			bAlwaysHardcoded ? "This is always hardcoded and changing it in XML requires recompiling the DLL." : "Use a non-hardcoded DLL or recompile the DLL to match your new XML setting."
			);
		gDLL->MessageBox(szMessage, "XML mismatch hardcoded DLL Error");
	}
}

static void DisplayXMLhardcodingError(const char* szName, const char* szAssumedName)
{
	DisplayXMLhardcodingError(strcmp(szName, szAssumedName) == 0, szName, false);
}

// Assign yields as strategic (for AI usage)
// Assign recursively meaning anything used to produce strategic yields will also be labeled strategic
static void AddStrategicYield(YieldTypes eYield, BoolArray& baStrategic, const ProfessionInfoArray& professionArray)
{
	if (baStrategic.get(eYield))
	{
		return;
	}
	// set the bool first as this prevents any theoredical risk of infinite loop due to yield A requireing B and B requireing A
	// Setting up yields like that is likely a mistake, but it shouldn't cause the game to crash with a stack overflow
	baStrategic.set(true, eYield);

	for (int i = 0;; ++i)
	{
		const CvProfessionInfo* pInfo = professionArray.get(i);
		if (pInfo == NULL) break;
		const InfoArray& produced = pInfo->getYieldsProducedArray();
		for (int j = 0; j < produced.getLength(); ++j)
		{
			if (produced.getYield(j) == eYield)
			{
				const InfoArray& consumed = pInfo->getYieldsConsumedArray();
				for (int iConsumed = 0; iConsumed < consumed.getLength(); ++iConsumed)
				{
					AddStrategicYield(consumed.getYield(iConsumed), baStrategic, professionArray);
				}
				break;
			}
		}
	}
}

void CvGlobals::postXMLLoad(bool bFirst)
{
	if (bFirst)
	{
#include "autogenerated/AutoXmlInit.h"

#ifndef HARDCODE_XML_VALUES
		// check that all yields are loaded
		DisplayXMLmissingError(YIELD_FOOD       , "YIELD_FOOD"       );
		DisplayXMLmissingError(YIELD_LUMBER     , "YIELD_LUMBER"     );
		DisplayXMLmissingError(YIELD_STONE      , "YIELD_STONE"      );
		DisplayXMLmissingError(YIELD_ORE        , "YIELD_ORE"        );
		DisplayXMLmissingError(YIELD_HORSES     , "YIELD_HORSES"     );
		DisplayXMLmissingError(YIELD_MUSKETS    , "YIELD_MUSKETS"    );
		DisplayXMLmissingError(YIELD_TOOLS      , "YIELD_TOOLS"      );
		DisplayXMLmissingError(YIELD_BLADES     , "YIELD_BLADES"     );
		DisplayXMLmissingError(YIELD_CANNONS    , "YIELD_CANNONS"    );
		DisplayXMLmissingError(YIELD_FUR        , "YIELD_FUR"        );

		DisplayXMLmissingError(YIELD_HAMMERS    , "YIELD_HAMMERS"    );
		DisplayXMLmissingError(YIELD_BELLS      , "YIELD_BELLS"      );
		DisplayXMLmissingError(YIELD_CROSSES    , "YIELD_CROSSES"    );
		DisplayXMLmissingError(YIELD_CULTURE    , "YIELD_CULTURE"    );
		DisplayXMLmissingError(YIELD_HEALTH     , "YIELD_HEALTH"     );
		DisplayXMLmissingError(YIELD_EDUCATION  , "YIELD_EDUCATION"  );

		// cargo yields by definition ends at hammers
		NUM_CARGO_YIELD_TYPES = YIELD_HAMMERS;

		for (HurryTypes eHurry = FIRST_HURRY; eHurry < NUM_HURRY_TYPES; ++eHurry)
		{
			const char *type = GC.getHurryInfo(eHurry).getType();
			if (strcmp(type, "HURRY_GOLD") == 0)
			{
				HURRY_GOLD = eHurry;
			}
			else if (strcmp(type, "HURRY_IMMIGRANT") == 0)
			{
				HURRY_IMMIGRANT = eHurry;
			}
		}

		int iCounter = 0;

		for (CivEffectTypes eCivEffect = FIRST_CIV_EFFECT; eCivEffect < NUM_CIV_EFFECT_TYPES; ++eCivEffect)
		{
			const char *szType = this->getCivEffectInfo(eCivEffect).getType();

			if (strcmp(szType, "CIV_EFFECT_DEFAULT_ALL") == 0)
			{
				CIV_EFFECT_DEFAULT_ALL = eCivEffect;
			}
			else if (strcmp(szType, "CIV_EFFECT_DEFAULT_EUROPEAN") == 0)
			{
				CIV_EFFECT_DEFAULT_EUROPEAN = eCivEffect;
			}
			else if (strcmp(szType, "CIV_EFFECT_DEFAULT_NATIVE") == 0)
			{
				CIV_EFFECT_DEFAULT_NATIVE = eCivEffect;
			}
			else if (strcmp(szType, "CIV_EFFECT_DEFAULT_KING") == 0)
			{
				CIV_EFFECT_DEFAULT_KING = eCivEffect;
			}
			else if (strcmp(szType, "CIV_EFFECT_DEFAULT_HUMAN") == 0)
			{
				CIV_EFFECT_DEFAULT_HUMAN = eCivEffect;
			}
			else if (strcmp(szType, "CIV_EFFECT_DEFAULT_AI") == 0)
			{
				CIV_EFFECT_DEFAULT_AI = eCivEffect;
			}
			else
			{
				continue;
			}
			++iCounter;
			if (iCounter == 6)
			{
				// all found. No need to loop the rest
				break;
			}
		}
		DisplayXMLmissingError(CIV_EFFECT_DEFAULT_ALL        != NO_CIV_EFFECT, "CIV_EFFECT_DEFAULT_ALL"       );
		DisplayXMLmissingError(CIV_EFFECT_DEFAULT_EUROPEAN   != NO_CIV_EFFECT, "CIV_EFFECT_DEFAULT_EUROPEAN"  );
		DisplayXMLmissingError(CIV_EFFECT_DEFAULT_NATIVE     != NO_CIV_EFFECT, "CIV_EFFECT_DEFAULT_NATIVE"    );
		DisplayXMLmissingError(CIV_EFFECT_DEFAULT_KING       != NO_CIV_EFFECT, "CIV_EFFECT_DEFAULT_KING"      );
		DisplayXMLmissingError(CIV_EFFECT_DEFAULT_HUMAN      != NO_CIV_EFFECT, "CIV_EFFECT_DEFAULT_HUMAN"     );
		DisplayXMLmissingError(CIV_EFFECT_DEFAULT_AI         != NO_CIV_EFFECT, "CIV_EFFECT_DEFAULT_AI"        );

#else

		DisplayXMLhardcodingError("CIV_EFFECT_DEFAULT_ALL"       , this->getCivEffectInfo(CIV_EFFECT_DEFAULT_ALL       ).getType());
		DisplayXMLhardcodingError("CIV_EFFECT_DEFAULT_EUROPEAN"  , this->getCivEffectInfo(CIV_EFFECT_DEFAULT_EUROPEAN  ).getType());
		DisplayXMLhardcodingError("CIV_EFFECT_DEFAULT_NATIVE"    , this->getCivEffectInfo(CIV_EFFECT_DEFAULT_NATIVE    ).getType());
		DisplayXMLhardcodingError("CIV_EFFECT_DEFAULT_KING"      , this->getCivEffectInfo(CIV_EFFECT_DEFAULT_KING      ).getType());
		DisplayXMLhardcodingError("CIV_EFFECT_DEFAULT_HUMAN"     , this->getCivEffectInfo(CIV_EFFECT_DEFAULT_HUMAN     ).getType());
		DisplayXMLhardcodingError("CIV_EFFECT_DEFAULT_AI"        , this->getCivEffectInfo(CIV_EFFECT_DEFAULT_AI        ).getType());

		DisplayXMLhardcodingError("HURRY_GOLD"                   , this->getHurryInfo(HURRY_GOLD                       ).getType());
		DisplayXMLhardcodingError("HURRY_IMMIGRANT"              , this->getHurryInfo(HURRY_IMMIGRANT                  ).getType());

#endif
		DisplayXMLmissingError(HURRY_GOLD      != NO_HURRY, "HURRY_GOLD");
		DisplayXMLmissingError(HURRY_IMMIGRANT != NO_HURRY, "HURRY_IMMIGRANT");

	}
	else // bFirst
	{
		// Now all xml data has been loaded

		// first test if DLL hardcoding and xml are out of sync
#include "autogenerated/AutoXmlTest.h"

		BoolArray baMilitary(JIT_ARRAY_YIELD);
		BoolArray baProfessionRequirement(JIT_ARRAY_YIELD);
		BoolArray baRaw(JIT_ARRAY_YIELD);
		BoolArray baProduced(JIT_ARRAY_YIELD);
		BoolArray baStrategic(JIT_ARRAY_YIELD);
		BoolArray baWeapon(JIT_ARRAY_YIELD);
		BoolArray baConstruction(JIT_ARRAY_YIELD);

		BoolArray baProductionProfessions(JIT_ARRAY_PROFESSION);

		// loop professions
		// goals:
		// - create a list of professions with both produced and consumed yields (needed later)
		// - set lists for equipment and military yields
		// - figure out if yields are prododuced or raw based on the production professions
		for (ProfessionTypes eProfession = FIRST_PROFESSION; eProfession < NUM_PROFESSION_TYPES; ++eProfession)
		{
			const CvProfessionInfo& kProfession = this->getProfessionInfo(eProfession);

			const InfoArray& arrayEquipment = kProfession.getYieldsEquipmentArray();
			int iLength = arrayEquipment.getLength();
			for (int i = 0; i < iLength; ++i)
			{
				YieldTypes eYield = arrayEquipment.getYield(i);
				baMilitary.set(true, eYield);
				baProfessionRequirement.set(true, eYield);
			}
			
			const InfoArray& arrayConsumed = kProfession.getYieldsConsumedArray();
			const InfoArray& arrayProduced = kProfession.getYieldsProducedArray();

			bool bProduced = false;

			if (arrayConsumed.getLength() > 0)
			{
				bProduced = true;
				if (arrayProduced.getLength() > 0)
				{
					baProductionProfessions.set(true, eProfession);
				}
			}

			
			iLength = arrayProduced.getLength();
			for (int i = 0; i < iLength; ++i)
			{
				YieldTypes eYield = arrayProduced.getYield(i);
				if (bProduced)
				{
					baProduced.set(true, eYield);
				}
				else
				{
					baRaw.set(true, eYield);
				}
			}
		}

		ProfessionInfoArray professionArray;

		professionArray.assign(baProductionProfessions);

		// find yields traded on the domestic market
		// set yields to be strategic when used for constructing buildings or units
		{
			YieldCargoArray<int> aYields;

			for (BuildingTypes eBuilding = FIRST_BUILDING; eBuilding < NUM_BUILDING_TYPES; ++eBuilding)
			{
				CvBuildingInfo &kBuilding = GC.getBuildingInfo(eBuilding);
				aYields.addCache(1, kBuilding.getYieldDemands());

				const InfoArray& costs = kBuilding.getYieldCosts();
				for (int i = 0; i < costs.getLength(); ++i)
				{
					AddStrategicYield(costs.getYield(i), baStrategic, professionArray);
				}
			}
			for (UnitTypes eUnit = FIRST_UNIT; eUnit < NUM_UNIT_TYPES; ++eUnit)
			{
				CvUnitInfo &kUnit = GC.getUnitInfo(eUnit);
				aYields.addCache(1, kUnit.getYieldDemands());

				const InfoArray& costs = kUnit.getYieldCosts();
				for (int i = 0; i < costs.getLength(); ++i)
				{
					AddStrategicYield(costs.getYield(i), baStrategic, professionArray);
				}
			}
			m_acUnitYieldDemandTypes.assign(aYields);
		}

		for (YieldTypes eYield = FIRST_YIELD; eYield < NUM_YIELD_TYPES; ++eYield)
		{
			const CvYieldInfo& kInfo = this->getYieldInfo(eYield);

			YieldCategoryTypes eYieldCategory = kInfo.getCategory();

			baWeapon.set(kInfo.isWeapon(), eYield);

			switch (eYieldCategory)
			{
			case YIELD_CATEGORY_HAMMERS:
			case YIELD_CATEGORY_BELLS:
			case YIELD_CATEGORY_CROSSES:
			case YIELD_CATEGORY_CULTURE:
			case YIELD_CATEGORY_HEALTH:
			case YIELD_CATEGORY_EDUCATION:
				FAssertMsg(!baProfessionRequirement.get(eYield), CvString::format("%s: non-cargo yields can't be used as yield requirements for professions", kInfo.getType()));
				FAssertMsg(!baMilitary.get(eYield), CvString::format("%s: non-cargo yields can't be used as yield requirements for professions", kInfo.getType()));
				baRaw.set(false, eYield);
				baProduced.set(false, eYield);
				baStrategic.set(false, eYield);
				break;
				case YIELD_CATEGORY_FOOD:
					baMilitary.set(true, eYield);
					/// FALLTHROUGH ///
				case YIELD_CATEGORY_CONSTRUCTION:
					baConstruction.set(eYieldCategory == YIELD_CATEGORY_CONSTRUCTION, eYield);
					/// FALLTHROUGH ///
				case YIELD_CATEGORY_TOOLS:
				case YIELD_CATEGORY_NEW_WORLD_CONSUMED:
					AddStrategicYield(eYield, baStrategic, professionArray);
				default:
					break;
			}
		}

		// assign caches in CvGlobals
		m_acYieldMilitary.assign(baMilitary);
		m_acYieldUnitEquipment.assign(baProfessionRequirement);
		m_acYieldRaw.assign(baRaw);
		m_acYieldProduced.assign(baProduced);
		m_acYieldStrategic.assign(baStrategic);
		m_acYieldWeapon.assign(baWeapon);
		m_acYieldConstruction.assign(baConstruction);

		// update cached settings in CvYieldInfo
		for (YieldTypes eYield = FIRST_YIELD; eYield < NUM_YIELD_TYPES; ++eYield)
		{
			this->getYieldInfo(eYield).postReadSetup(professionArray);
		}
		for (YieldTypes eYield = FIRST_YIELD; eYield < NUM_YIELD_TYPES; ++eYield)
		{
			this->getYieldInfo(eYield).postReadSetup2();
		}

		// Generate the default CivEffect.
		// It's given to all players and enables everything, which can't be enabled by CivEffect.
		// If it isn't explicitly enabled, it's assumed to be available from the start.
		this->m_pAutogeneratedCivEffect = new CivEffectInfo(true);
	}
}
