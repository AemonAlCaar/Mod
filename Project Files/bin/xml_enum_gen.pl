#!/usr/bin/perl -w


use strict;
use warnings;

use File::Slurp;

use XML::LibXML;
use lib './bin';
use XMLlists;

my $FILE         = getAutoDir() . "/AutoXmlEnum.h";
my $FILE_TEST    = getAutoDir() . "/AutoXmlTest.h";
my $FILE_DECLARE = getAutoDir() . "/AutoXmlDeclare.h";
my $FILE_INIT    = getAutoDir() . "/AutoXmlInit.h";

my $files = [];
my %varToEnum;

my $output         = "";
my $output_test    = "";
my $output_declare = "";
my $output_init    = "";

$output .= "#ifndef AUTO_XML_ENUM\n";
$output .= "#define AUTO_XML_ENUM\n";
$output .= "\n";
$output .= "// Autogenerated file. Do not edit!!!\n";
$output .= "\n";
$output .= "// Each of the enums in this file represent an xml file.\n";
$output .= "// Civ4 has always hardcoded some xml data this way and modders have always had issues with dll and xml going out of sync.\n";
$output .= "// \n";
$output .= "// This file will hopefully solve the out of sync problem for good.\n";
$output .= "// The makefile will update this file if needed each time the compiler is used.\n";
$output .= "// As a result, a compiled DLL will always match the xml files at the time of compilation.\n";
$output .= "// \n";
$output .= "// The debugger is aided by this file.\n";
$output .= "// The debugger will use the names given in this file, like UNIT_WAGON_TRAIN(81) instead of just 81.\n";
$output .= "// It would be nice to trick the debugger to assume hardcoded even if the DLL isn't, but for the time being the debugger prefers hardcoded DLL files.\n";
$output .= "// \n";
$output .= "// The file can optionally hardcode everything (it doesn't by default. It has to be enabled)\n";
$output .= "// Hardcoding can help the compiler optimization, but it shouldn't be used if somebody wants to edit xml files.\n";
$output .= "// \n";
$output .= "// All hardcoded data will be assert checked at startup.\n";
$output .= "\n";

$output_test .= "\n";
$output_test .= "// Autogenerated file. Do not edit!!!\n";
$output_test .= "\n";

$output_declare .= "\n";
$output_declare .= "// Autogenerated file. Do not edit!!!\n";
$output_declare .= "\n";
$output_declare .= "#ifndef HARDCODE_XML_VALUES\n";

$output_init .= "\n";
$output_init .= "// Autogenerated file. Do not edit!!!\n";
$output_init .= "\n";
$output_init .= "#ifndef HARDCODE_XML_VALUES\n";
$output_init .= "if (bFirst) {\n";

foreach my $file (getEnumFiles())
{
	processFile($file);
}

$output_init .= "} else {\n";

handleGlobalDefineALT();

$output .= "\n#endif // AUTO_XML_ENUM\n";
$output_declare .= "#endif\n";
$output_init .= "}\n#endif\n";

writeFile($FILE        , \$output        );
writeFile($FILE_TEST   , \$output_test   );
writeFile($FILE_DECLARE, \$output_declare);
writeFile($FILE_INIT   , \$output_init   );

sub getChild
{
	my $parent = shift;
	my $name = shift;
	
	my $element = $parent->firstChild;
	
	while (1)
	{
		return if (ref($element) eq "");
		if (ref($element) eq "XML::LibXML::Element")
		{
			return $element if $name eq "" or $element->nodeName eq $name;
		}
		$element = $element->nextSibling;
	}
}

sub nextSibling
{
	my $element = shift;
	
	$element = $element->nextSibling;
	while (ref($element) ne "XML::LibXML::Element" and ref($element) ne "")
	{
		$element = $element->nextSibling;
	}
	return $element;
}

sub processFile
{
	my $filename = shift;

	my ($basename, $enum, $TYPE) = getXMLKeywords($filename);
	
	my $isHardcoded = isAlwaysHardcodedEnum($filename);
	
	my $hardcodedBool = "true";
	$hardcodedBool = "false" unless $isHardcoded;
	
	my $isYield = $enum eq "YieldTypes";

	$output .= "enum ";
	$output .= $enum . "\n{\n";
	$output .= "\tINVALID_PROFESSION = -2,\n" if $basename eq "Profession";
	$output .= "\t" . getNoType($TYPE) . " = -1,\n\n";
	$output .= "#ifdef HARDCODE_XML_VALUES\n\n" unless $isHardcoded;
	
	foreach my $type (getTypesInFile($filename))
	{
		$varToEnum{$type} = $enum;
		$output .= "\t" . $type . ",\n";
		$output_test .= "DisplayXMLhardcodingError(strcmp(\"". $type . "\", " . getInfo($basename) . "($type).getType()) == 0, \"$type\", true);\n" if $isHardcoded;
	}

	$output_test .= "DisplayXMLhardcodingError(NUM_" . $TYPE . "_TYPES == (" . $enum . ")" . getNumFunction($basename) . ", \"NUM_" . $TYPE . "_TYPES\", " . $hardcodedBool . ");\n";

	$output .= "\n\tNUM_" . $TYPE . "_TYPES,\n";
	$output .= "\tNUM_CARGO_YIELD_TYPES = YIELD_HAMMERS,\n" if $isYield;
	$output .= "\n\tCOMPILE_TIME_NUM_" . $TYPE . "_TYPES = NUM_" . $TYPE . "_TYPES,\n";
	
	unless ($isHardcoded)
	{
		$output .= "\n#else // HARDCODE_XML_VALUES\n";
		$output .= "\n\tCOMPILE_TIME_NUM_" . $TYPE . "_TYPES = MAX_SHORT,\n";
		$output .= "\n#endif // HARDCODE_XML_VALUES\n";
	}
	
	$output .= "\n\tFIRST_" . $TYPE . " = 0,\n";
	$output .= "};\n\n";
	
	unless ($isHardcoded)
	{
		$output .= "#ifndef HARDCODE_XML_VALUES\n";
		$output .= "extern const " . $enum . "& NUM_" . $TYPE . "_TYPES;\n";
		$output .= "#endif\n\n";
		$output_declare .= $enum . " NUM_" . $TYPE . "_TYPES_NON_CONST;\n";
		$output_declare .= "const " . $enum . "& NUM_" . $TYPE . "_TYPES = NUM_" . $TYPE . "_TYPES_NON_CONST;\n";
		$output_init .= "NUM_" . $TYPE . "_TYPES_NON_CONST = (" . $enum . ")" . getNumFunction($basename) . ";\n";
	}
	$output .= "#define NUM_" . substr($enum, 0, -5) . "_TYPES NUM_" . $TYPE . "_TYPES\n\n"
}

sub getTypesInFile
{
	my $filename = shift;
	
	my $fileWithPath = getFileWithPath($filename);
	
	if ($fileWithPath)
	{
		my $dom = XML::LibXML->load_xml(location => $fileWithPath);
		
		my $loopElement = getChild($dom, "");
		$loopElement = getChild($loopElement, "");
		$loopElement = getChild($loopElement, "") unless isTwoLevelFile($filename);
		
		my @types = ();
		
		while (ref ($loopElement) ne "")
		{
			my $child = getChild($loopElement, "Type");
			die $filename . " failed to read elements" unless $child;
			push(@types, $child->textContent);
			$loopElement = nextSibling($loopElement);
		}
		return @types;
	}
	
	# the file isn't present in the mod. Add the vanilla values
	# no need to look up vanilla. That can cause issues and we know the values even without looking
	return ("DOMAIN_SEA", "DOMAIN_LAND", "DOMAIN_IMMOBILE") if $filename eq "BasicInfos/CIV4DomainInfos.xml";
	return ("FATHERCATEGORY_EXPLORATION", "FATHERCATEGORY_RELIGION", "FATHERCATEGORY_TRADE", "FATHERCATEGORY_MILITARY", "FATHERCATEGORY_POLITICS") if $filename eq "BasicInfos/CIV4FatherCategoryInfos.xml";
	return ("ALARM_DEFAULT") if $filename eq "Civilizations/CIV4AlarmInfos.xml";
	return ("CIVICOPTION_SLAVERY", "CIVICOPTION_ELECTION", "CIVICOPTION_NATIVES", "CIVICOPTION_RELIGION", "CIVICOPTION_SECURITY") if $filename eq "GameInfo/CIV4CivicOptionInfos.xml";
	return ("CLIMATE_TEMPERATE", "CLIMATE_TROPICAL", "CLIMATE_ROCKY") if $filename eq "GameInfo/CIV4ClimateInfo.xml";
	return ("EUROPE_EAST", "EUROPE_WEST", "EUROPE_NORTH", "EUROPE_SOUTH") if $filename eq "GameInfo/CIV4EuropeInfo.xml";
	return ("HURRY_GOLD", "HURRY_IMMIGRANT") if $filename eq "GameInfo/CIV4HurryInfo.xml";
	return ("SEALEVEL_LOW", "SEALEVEL_MEDIUM", "SEALEVEL_HIGH") if $filename eq "GameInfo/CIV4SeaLevelInfo.xml";
	
	die "getTypesInFile: " . $filename . " not supported\n";
}


sub writeFile
{
	my $file = shift;
	my $text = shift;
	
	if (-e $file)
	{
		my $file_content = read_file($file);
		# return if the two files are identical
		# updating anyway will for an unneeded recompilation
		return if $file_content eq $$text;
	}

	open (my $output_file, "> " . $file) or die "Can't open file " . $file . "\n" . $!;
	print $output_file $$text;
	close $output_file;
}

sub handleGlobalDefineALT
{
	my %value;
	my %vartype;
	my %hardcoded;
	
	my $declare_hardcoded = "";
	my $declare_dynamic = "";
	
	
	my $filename = "../Assets/XML/GlobalDefinesAlt.xml";
	my $tag = "";
	my $lineno = 0;
	my $state = -1;
	
	open(my $fh, '<:encoding(UTF-8)', $filename)
	  or die "Could not open file '$filename' $!";

	while (my $line = <$fh>)
	{
		$lineno += 1;
		if ($line =~ /\Q<DefineName>\E/)
		{
			$tag = substr($line, index($line, ">")+1);
			$tag = substr($tag, 0, index($tag, "<"));
			$hardcoded{$tag} = 0;
			$state = 0;
		}
		elsif ($state == 0)
		{
			if ($line =~ /\Q<iDefineIntVal>\E/)
			{
				my $number = substr($line, index($line, ">")+1);
				$number = substr($number, 0, index($number, "<"));
				$value{$tag} = $number;
				$vartype{$tag} = "int";
				$state = 1;
			}
			elsif ($line =~ /\Q<DefineTextVal>\E/)
			{
				my $valueStr = substr($line, index($line, ">")+1);
				$valueStr = substr($valueStr, 0, index($valueStr, "<"));
				my $type = $varToEnum{$valueStr} || continue;
				$vartype{$tag} = $type;
				$value{$tag} = $valueStr;
				$state = 1;
			}
		}
		elsif ($state == 1 and $line =~ /\Q<bAlwaysHardcoded>1<\/bAlwaysHardcoded>\E/)
		{
			$state = -1;
			$hardcoded{$tag} = 1;
		}
		
	}
	
	$output .= "// GlobalDefinesAlt\n";
	
	foreach my $tag (sort keys %value)
	{
		my $var = "GLOBAL_DEFINE_" . $tag;
		
		if ($hardcoded{$tag})
		{
			$output .= "const $vartype{$tag} $var = $value{$tag};\n";
			if ($vartype{$tag} eq "int")
			{
				$output_test .= "DisplayXMLhardcodingError($var == $value{$tag}, \"$tag\", true);\n";
			}
			else
			{
				$output_test .= "DisplayXMLhardcodingError($var == static_cast<$vartype{$tag}>(GC.getDefineINT(\"$value{$tag}\")), \"$tag\", true);\n";
			}
		}
		else
		{
			$declare_hardcoded .= "const $vartype{$tag} $var = $value{$tag};\n";
			$declare_dynamic .= "extern const $vartype{$tag}& $var;\n";
			$output_declare .= "$vartype{$tag} " . $var . "_NON_CONST;\n";
			$output_declare .= "const $vartype{$tag}& $var = " . $var . "_NON_CONST;\n";
			if ($vartype{$tag} eq "int")
			{
				$output_init .= $var . "_NON_CONST = GC.getDefineINT(\"$tag\");\n";
				$output_test .= "DisplayXMLhardcodingError($var == GC.getDefineINT(\"$tag\"), \"$tag\", false);\n";
			}
			else
			{
				$output_init .= $var . "_NON_CONST = static_cast<$vartype{$tag}>(getIndexForType(VARINFO<$vartype{$tag}>::JIT, \"$value{$tag}\"));\n";
				$output_test .= "DisplayXMLhardcodingError($var == static_cast<$vartype{$tag}>(getIndexForType(VARINFO<$vartype{$tag}>::JIT, \"$value{$tag}\")), \"$tag\", false);\n";
			}
			
		}
	}
	
	$output .= "#ifdef HARDCODE_XML_VALUES\n";
	$output .= $declare_hardcoded;
	$output .= "#else\n";
	$output .= $declare_dynamic;
	$output .= "#endif // hardcoded xml\n";
	
}
