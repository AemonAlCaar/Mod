#!/usr/bin/perl -w


use strict;
use warnings;

use Data::Dumper;

use XML::LibXML::Reader;
use lib './bin';
use XMLlists;


my @enums;
my %enumValues;

my @enumsToSkip =
(
	"AnimationOperatorTypes",
	"FunctionTypes",
	"DiplomacyPowerTypes",
	"AutomateTypes",
	"DirectionTypes",
	"InterfaceVisibility",
	"ArtStyleTypes",
	"ContactTypes",
	"CitySizeTypes",
	"FootstepAudioTypes",
);

my @enumsToNotUseEnumCounter =
(
	"AnimationOperatorTypes",
	"ArtStyleTypes",
	"AutomateTypes",
	"FootstepAudioTypes",
);


my $FILE         = getAutoDir() . "/AutoGlobalDefineEnum.h";
my $FILE_CPP     = getAutoDir() . "/AutoGlobalDefineEnumCpp.h";

my $output         = "";

$output .= "#ifndef AUTO_XML_ENUM_GLOBAL\n";
$output .= "#define AUTO_XML_ENUM_GLOBAL\n";
$output .= "\n";
$output .= "// Autogenerated file. Do not edit!!!\n";
$output .= "\n";



getTypesInFile("GlobalTypes.xml");



foreach my $enum (@enums)
{
	next if shouldSkipEnum($enum);
	
	$output .= "enum " . $enum . "\n{\n";
	$output .= "\tNO_" . getEnumUpperCase($enum) . " = -1,\n";
	
	foreach my $value (@{$enumValues{$enum}})
	{
		$output .= "\t";
		$output .= $value;
		$output .= ",\n";
	}
	my $upperName = getEnumUpperCase($enum);
	
	$output .= "\n\tNUM_" . $upperName . "_TYPES,\n";
	$output .= "\tFIRST_" . $upperName . " = 0,\n";
	$output .= "};\n\n";
}

$output .= "#endif\n";

writeFile($FILE        , \$output        );

$output = "\n// autogeneted file!\n// do not edit\n\n";
$output .= "#include \"../CvEnumsFunctions.h\"\n\n";

foreach my $enum (@enums)
{
	$output .= "\ntemplate<>\n";
	$output .= "const char* getTypeStr(" . $enum . " eIndex)\n{\n";
	$output .= "\tswitch(eIndex)\n\t{\n";
	
	my $i = 0;
	foreach my $value (@{$enumValues{$enum}})
	{
		$output .= "\t\tcase ";
		if (useEnumNamesAsCounter($enum))
		{
			$output .= $value;
		}
		else
		{
			$output .= $i;
			$i = $i + 1;
		}
		$output .= ": return \"" . $value . "\";\n";
	}
	$output .= "\t}\n";
	$output .= "\treturn \"\";\n";
	$output .= "}\n";

}

writeFile($FILE_CPP     , \$output        );


exit();



sub getTypesInFile
{
	my $filename = shift;
	
	my $fileWithPath = getFileWithPath($filename);
	
	if ($fileWithPath)
	{
		my $reader = XML::LibXML::Reader->new(location => $fileWithPath)
			or die "cannot read file '$fileWithPath': $!\n";
		
		my $enumSet = 0;
		my $enum = "";
		
		
		while($reader->read)
		{
			if ($reader->nodeType == 1 and $reader->depth == 1)
			{
				$enumSet = 0;
				$enum = getEnumName($reader->name);
			}
			elsif ($reader->nodeType == 3 and $reader->depth == 3)
			{
				if ($enumSet == 0)
				{
					$enumSet = 1;
					push(@enums, $enum);
					$enumValues{$enum} = ();
					
				}
				push(@{$enumValues{$enum}}, $reader->value);
			}
		}
	}
}

sub getEnumName
{
	my $enum = shift;
	return "InterfaceVisibility" if $enum eq "InterfaceVisibilityTypes";
	return $enum;
}

sub shouldSkipEnum
{
	my $enum = shift;
	
	foreach my $loop_enum (@enumsToSkip)
	{
		return 1 if $enum eq $loop_enum;
	}
	return 0;
}

sub useEnumNamesAsCounter
{
	my $enum = shift;
	
	foreach my $loop_enum (@enumsToNotUseEnumCounter)
	{
		return 0 if $enum eq $loop_enum;
	}
	return 1;
}

sub getChild
{
	my $parent = shift;
	my $name = shift;
	
	my $element = $parent->firstChild;
	
	while (1)
	{
		return if (ref($element) eq "");
		if (ref($element) eq "XML::LibXML::Element")
		{
			return $element if $name eq "" or $element->nodeName eq $name;
		}
		$element = $element->nextSibling;
	}
}

sub nextSibling
{
	my $element = shift;
	
	$element = $element->nextSibling;
	while (ref($element) ne "XML::LibXML::Element" and ref($element) ne "")
	{
		$element = $element->nextSibling;
	}
	return $element;
}

sub getEnumUpperCase
{
	my $original = shift;
	my $result = substr($original, 0, 1);
	
	$original = substr($original, 1);
	
	if (substr($original, -5) eq "Types")
	{
		$original = substr($original, 0, -5);
	}
	
	foreach my $char (split //, $original)
	{
		my $newChar = uc($char);
		$result .= "_" if $char eq $newChar;
		$result .= $newChar;
	}
	
	return $result;
}
